
# ELF Fundamentals 

ELF (Executable and Linking Format) is the Linux and unix executable file type.

An ELF file consists of an ELF header and ELF data. It can be examined using the readelf command.

An ELF header contains important information for the OS on how to handle the file. Here are the most important parts of the header.


- It starts with the following hex sequence 7f 45 4c 46

- Class defines the target architecture 

- Data refers to the type of endianness (little or big)

- Type can be CORE (core dumps), DYN (shared objects), EXEC (executables) or REL (relocatable files)

- Core dumps are products of memory corruption. They can be fed to gdb in order to examine crashed programs more accurately. We will use core dumps later on during exploit development.


Before we move on to the remaining three types, we need to first understand what linkers and loaders are.


Linkers are responsible for taking the names of functions and linking them to their actual locations in memory.  During a call to a function, the linker is responsible for location its memory address within a system library and then writing it to the process memory of the executable, so that the function can be accessed at that address. The task of a loader is to load programs from storage into memory.


If an executable requests to be loaded at a memory address that is already occupied, it needs to be relocated. Relocation simply means moving the module to another place in memory to avoid address collisions.

As this should be done in an organized manner, ELF files contain a .reloc section. Whenever the desired loading address is unavailable, the .reloc section is responsible for patching that program with the new addresses. In ordder to be able to do that, relative addressing is used to describe the address of program functions. 


- Relative addressing describes a function address by the offset from the loading base address and not by the full address

For example, if the relative virtual address of a function is 0x123 and its program is loaded at 0x804000, the function can be found at 0x804123.


Furthermore, executable files might also contain symbols. Symbols are a description of the executable code and include, among others, function and variable names.

During compilation, the creator of an executable may decide to turn off support for symbols.


Symbols make debugging a lot easier since many function and variable names give a hint on what they are supposed to do; for example, finding functions named getName() or printName() can save us from a lot of reverse engineering activites.

- The process of removing symbols from an ELF file is called stripping


With some Linux exectuable handling concepts now explained, lets go back to defining the three remaining ELF file types.

# EXEC (executables), REL (relocatable files), DYN (shared objects)

- Executable files can be mapped directly into memory upon execution

- Relocatable files are executables supporting the relocation process

In cases of address conflict, they make use of relative addressing and change the address of their components with a constant offset to their dynamic base address.


Shared Objects are libraries of functions. From a technical perspective, they contain sections typical for both executable and relocatable files. They can be often recognized by their .so extension

Shared objects are loaded into a program that makes use of them during startup



Sections are some standard places within an ELF file that play a certain role in its functionalities. Upon startup, sections are mapped into the process memory. Mapping means storing them in the memory of a newly created process with respect to their size and contained data

Sections also have certain permissions - read, write and execute - none or all of them are theoretically possible to 