
# ELF Fundamentals 

ELF (Executable and Linking Format) is the Linux and unix executable file type.

An ELF file consists of an ELF header and ELF data. It can be examined using the readelf command.

An ELF header contains important information for the OS on how to handle the file. Here are the most important parts of the header.


- It starts with the following hex sequence 7f 45 4c 46

- Class defines the target architecture 

- Data refers to the type of endianness (little or big)

- Type can be CORE (core dumps), DYN (shared objects), EXEC (executables) or REL (relocatable files)

- Core dumps are products of memory corruption. They can be fed to gdb in order to examine crashed programs more accurately. We will use core dumps later on during exploit development.


Before we move on to the remaining three types, we need to first understand what linkers and loaders are.


Linkers are responsible for taking the names of functions and linking them to their actual locations in memory.  During a call to a function, the linker is responsible for location its memory address within a system library and then writing it to the process memory of the executable, so that the function can be accessed at that address. The task of a loader is to load programs from storage into memory.


If an executable requests to be loaded at a memory address that is already occupied, it needs to be relocated. Relocation simply means moving the module to another place in memory to avoid address collisions.

As this should be done in an organized manner, ELF files contain a .reloc section. Whenever the desired loading address is unavailable, the .reloc section is responsible for patching that program with the new addresses. In ordder to be able to do that, relative addressing is used to describe the address of program functions. 


- Relative addressing describes a function address by the offset from the loading base address and not by the full address

For example, if the relative virtual address of a function is 0x123 and its program is loaded at 0x804000, the function can be found at 0x804123.


Furthermore, executable files might also contain symbols. Symbols are a description of the executable code and include, among others, function and variable names.

During compilation, the creator of an executable may decide to turn off support for symbols.


Symbols make debugging a lot easier since many function and variable names give a hint on what they are supposed to do; for example, finding functions named getName() or printName() can save us from a lot of reverse engineering activites.

- The process of removing symbols from an ELF file is called stripping


With some Linux exectuable handling concepts now explained, lets go back to defining the three remaining ELF file types.

# EXEC (executables), REL (relocatable files), DYN (shared objects)

- Executable files can be mapped directly into memory upon execution

- Relocatable files are executables supporting the relocation process

In cases of address conflict, they make use of relative addressing and change the address of their components with a constant offset to their dynamic base address.


Shared Objects are libraries of functions. From a technical perspective, they contain sections typical for both executable and relocatable files. They can be often recognized by their .so extension.

- Shared objects are loaded into a program that makes use of them during startup



Sections are some standard places within an ELF file that play a certain role in its functionalities. Upon startup, sections are mapped into the process memory. Mapping means storing them in the memory of a newly created process with respect to their size and contained data.

Sections also have certain permissions - read, write and execute - none or all of them are theoretically possible to be enabled for a section.


According to Permissions, while a program is running and data from a certain section should be used, operations on those areas may or may not be restricted. for example, if a section (basically a memory area) is read only, the program will not be able to write new data to this area. 

The most common sections are: 
# .data - Initialized data with read/write access rights
# .rodata - Initialized data with read only access rights
# .bss - Uninitialized data with read and write access rights


There are two sections that are very important for every excecutable:
# .GOT (Global Offset Table) holds the addresses of functions
# .PLT (Procedure Linkage Table) holds the function stubs that point to the .GOT entry

As you can imagine, both (first the PLT and then the GOT) are used while a program attempts to locate and call a certain function. Note that a place in the program where function addresses are held will become more useful during exploit development. 



To conclude the ELF files subject, lets also cover SUID files. SUID files are a type of ELF file that is quite interesting when it comes to exploitation on Linux and Unix.

SUID and SGID files can be distinguished on Linux as they have a lowercase "s" in their security descriptor such as     -rwsr-s--x

If a SUID (Set User Identification) or SGID (Set Group Identification) program is launched, its effective UID (or GID) becomes the owner of the file.

- If you run a SUID root program, this program runs with root privileges
- If you run a SGID program, the program runs with privileges as if you were a member of that group

Even if you run a program as root, this doesnt mean that you elevated your privileges. The actions you might take as root are limited by the programs functionalities. Also, as a program is running as root, you cannot attach gdb to it and change the execution flow manually, due to lack of privileges. 

However, if there is an exploitable flaw within a SUID root program and you manage to spawn a shell via exploiting that flaw, there is a high likelihood that the shell spawned will be a root shell. 

In other words, SUID programs when exploited can allow for privilege escalation.

When performing post-exploitation activities on Linux systems, it is always worth paying attention to the SUID and SGID files, as they can often be primitive binaries prone to stack-based buffer overflow attacks. 

We will complete our first exploit and try to execute it later in this module.

